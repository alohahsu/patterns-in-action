package cn.windssoft.patterns.structure;

public class SocketAdapter implements DBSocketInterface{   //实现旧接口

	//定义：
	//座系统：原有的保留系统，被插。
	//插系统：原有的另一个保留系统，插入。
	//插入：插系统插入座系统。实现办法：实现座系统的一个接口。
	//为什么是这个实现办法？
	//座系统默认把持一个接口，如右图所示：OOOO<
	//为什么座系统能把持一个接口？如果座系统组织良好，它一定是一棵类树，顶端一定是一个抽象的东西，比如接口。
	//也就是说每个系统默认都是带有一些插孔的。
	//插系统也一样，默认也是带有一些插孔的。如有图所示：1111(
	//开始构造适配器
	//-----
	//那么适配器主体是：----
	//先让适配器带有插系统口：----)
	//实现办法是在适配器里添加一个插系统（插系统的某个类）的成员变量。
	//然后给适配器加装座系统类型的插头，现在适配器如有图所示：<----)
	//办法是：适配器实现座系统的接口。
	//构造适配器结束--------

	//插入动作的开展
	//======开始=======
	//拿来插系统的一个实物：1111(   or   )1111   （翻转一下就可以了）
	//创造一个适配器实物：<----)
	//并把插系统实物塞入适配器：<----))1111
	//在场景中就可以使用这个适配器了：0000<<----))1111
	//这样两个保留系统：0000< & )1111
	//就被组合在一起了。
	//======结束=======

	//总结
	//定义接口：一个在场景（框架）中和实现中都要遵循的协议，模型标准，样式等：<
	//实现接口，让一个类带有特定的插：<====     or     ====>
	//框架实现，让某个类（系统）带有槽     -----<  or >----
	//场景运转，连接这些匹配的系统：====>>----
	//多样式系统，比如有超过二种的系统：1111>    2222)    3333}    4444]
	//如果想连接系统1和系统3，则要构造一个适配器：}---<
	//匹配：3333}}----<<1111

	//适配有方向性
	//适配的去向是座系统
	//适配的来向是插系统
	//适配不能反插
	//持有一个类的实例成员，就意味着，这个地方可以被插，这个地方是个槽。

	//组合新接口
	private GBSocketInterface gbSocket;

	/**
	 * 在创建适配器对象时，必须传入一个新街口的实现类
	 */
	public SocketAdapter(GBSocketInterface gbSocket) {
		this.gbSocket = gbSocket;
	}


	/**
	 * 将对就接口的调用适配到新接口
	 */
	@Override
	public void powerWithTwoRound() {
		gbSocket.powerWithThreeFlat();
	}

}
